\documentclass[11pt]{article}
\usepackage{cs65f12}
\usepackage{times}
\usepackage{latexsym}
\usepackage{ulem}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}
\setlength\titlebox{6.5cm}    % Expanding the titlebox

\title{BatTrace: Android battery performance testing via system call tracing}

\author{Yeayeun Park\\
{\tt ypark2@swarthmore.edu}
\And 
Mark Serrano\\
{\tt mserran2@swarthmore.edu}
\AND
Craig Pentrack\\                 
{\tt cpentra1@swarthmore.edu}}

\date{12/06/13}

\begin{document}
\maketitle
\begin{abstract}
  The increasing number of tasks we can perform on our mobile devices 
  feeds positively into the demand for devices with longer battery power. 
  Since mobile devices have become integral parts of our daily lives with
  the number of tasks we can accomplish far outpacing battery performance 
  improvements, consumers have increasingly encountered the issue of 
  efficient device usage and battery life management. In this paper, we 
  examine Android devices in particular and present BatTrace, an Android 
  analysis tool that evaluates battery performance on the android platform
  by tracing system calls. BatTrace will execute different types of popular system
  calls, and extract the correlation between a particular system call and its 
  influence on the battery. Subsequently, it will trace system calls made by 
  individual Android applications and use system call performance data to profile
  each application. Finally, the analysis on the correlation between system calls and their 
  battery usage, as well as the correlation between each application and system 
  calls they initiate, will be combined to estimate battery usage 
  of individual Android applications.
\end{abstract}

\section{Introduction}
Our project is motivated by an issue that we face daily: limited battery power 
on our mobile devices. The vast power available at our fingertips in mobile
devices is tamed by the amount of battery physically available. Wanting to track application behavior 
and the resultant energy usage, we used \textit{strace} in combination with C programs and Android system data to perform 
dynamic analysis on Android devices, uncovering low-level explanations as to what is really 
draining the battery.

Hypothesizing system calls to be the key to understanding battery usage at a low-level, we 
used \textit{strace} to profile applications system call usage.  Such testing gave us aggregate
statistics on which system calls were used and how often.  In the process of tracing popular
3rd party applications (e.g. Facebook, Gmail, etc.), we also recorded battery usage by utilizing
built in Android system data pre and post traces.  

Once aware of the most used system calls, we created C programs to repeatedly run those calls and
collect battery statistics.  It is important to note that in future versions of BatTrace we will need to collect
statistics on all system calls, as the most frequent calls may not drain the most power.  However, starting with the 
most frequent system calls and the C programs repeatedly ran, we acquired an avetage measure of how much battery each system call 
consumes.  From the aggregate trace data and average system call consumption data, we were 
able to make predictions on battery usage of 3rd party applications.  In collecting high level 
data on battery consumption, we hope to better inform Android users which applications drain their 
battery level most, providing a good set of guidelines for mobile users to follow when low battery 
crisises hit.  With our fine-grained system call data, we hope to better inform software developers 
and hardware manufacturers which system calls consume the most power.   

\section{Background and related work}

Historically much power consumption research has focused on using utilization-based
methods (on individual components, e.g. CPU).  However, modern smartphones employ complex 
power strategies in device drivers and OS-level power management, sometimes rendering utilization as a poor 
model for representing power states and deducing battery usage ~\cite{pathak-systemcall}.  While 
sometimes strong correlation exists between utilization and power consumption, often 
applications have constant power consumption while in certain states (while 
utilization fluctuates) or have high power consumption while low utilization ~\cite{pathak-systemcall,google-androiddev}.  
Merely focusing on CPU and other component-specific 
utilization levels do not capture tail-power states and the more intricate workings of power management.
Additionally, measuring utilization via performance counters results in accuracy 
loss ~\cite{pathak-systemcall}.  

Instead of modeling power with utilization, system calls, the only way of 
interacting with hardware and performing I/O, serve as a much more precise indicator 
of power consumption ~\cite{pathak-systemcall}.  System calls, an indispensible aspect of mobile applications, 
provide accessible insight in how an application is using the underlying hardware.  Past work and tools, most 
notably eProf, show correlating application behavior with power usage (via system calls and power readings) has 
been more successful than utilization-based approaches ~\cite{pathak-systemcall,yoon-appscope,pathak-eprof,ding-signals}.  
Using the findings of eProf and other studies as justification, we measured and classified system 
calls on Android smartphones in terms of their effect on battery life.

While eProf foregrounded system calls as an effective indicator of changes in power
state, eProf used system calls as a means toward profiling applications' power 
consumption on a sub-routine level ~\cite{pathak-systemcall,pathak-eprof}.  Developing models based off of system 
calls supplied a powerful tool, however the eProf research did not study battery drain 
as a result of  particular system calls themselves and the frequency with which 
applications rely on certain system calls.  Other work in smartphone battery 
research, including detecting energy-related bugs, correlating wireless signal strength 
with battery consumption, and generating battery usage information on the process or 
application level, has relied on system calls ~\cite{yoon-appscope,pathak-bugs,ding-signals}.  We plan to supplement the 
research area by focusing our study on the system calls themselves, rather than using 
them as a means in tracking changes in power state, detecting bugs, measuring signal 
strength effects, or producing higher-level profilings as explored previously.

\section{Our Idea}

While dynamic analysis on traditional devices involves the most efficient use of finite 
computing resources, mobile devices introduce a new problem; finite power. The issue we 
immediately encounter when trying to analyze mobile software applications is that we 
\sout{almost} never have access to the source code of the applications. This is 
especially true given the fact that most mobile software is proprietary in nature, 
leaving open source software to the relics that are desktop computers.

\begin{figure}[h]
  \centerline{
        \includegraphics[width=90mm]{images/environment_graphic.png}
  }
  \caption{The Android environment stack. Trace location marks where we will be intercepting system calls}
  
 \end{figure}

With this in mind we set out find a way of measuring mobile battery usage at very low level
(software wise). We decided a good approach would involve monitoring activity at the system 
call level using \textit{strace}. We wanted to profile a variety of system calls 
based on how much battery is used while they are running. We intended to establish a baseline 
battery consumption level so we know how much battery is used by just the OS. Then, using 
simple programs that repeatedly make the same system call many times, as a single call is often
immeasurable, we can determine how much battery was used as a result of initiating a particular system call.  

Once system calls were profiled, we proceeded to the last phase of the analysis. Our 
goal was to identify the system calls initiated by the Dalvik VM as a result of running an 
individual app. By identifying the types of system calls, as well as the number of calls made 
to an individual system call, we were able to predict applications' impact on the battery based 
on what we learned about battery usage for individual system calls. While this approach may not 
be the most accurate, we believe it is an approach that will allow us to profile any 
application regardless of the author or the nature of the software's license.  Another possible method
to explore could be instrumenting low-level code as system calls execute, much in the fashion of popular
tools like Valgrind and Pin.

\section{Evaluation}

In the process of analyzing battery usage through system call tracing we successfully
found most used system calls by popular Android applications, wrote C programs to 
repeatedly execute those system calls, recorded battery usage as a result of particular 
system calls, gathered system call data of popular apps dynamically, and made predictions 
based on the aforementioned data.  This section is split into subsections based on the above
categories.

\subsection{Popular System Calls}

In order calculate accurate estimates of battery usage, we first traced 10 popular Android
applications to acquire a list of the most significant system calls (i.e. ones that were
called with the highest frequency).  We traced Google Maps, Facebook, Angry Birds, Youtube, Google Play,
Gmail, Twitter, Skype, Pandora, and Instagram using \textit{strace}, collecting the ten most 
used system calls by each.  Applications were run for at least 2 minutes simulating normal 
usage patters. The results appear in the Table 4.1.1.

Distilling the results, we found that there were 14 most frequent and unique system calls. They included:
clock\_gettime, ioctl, getpid, epoll\_wait, getuid32, futex, read, mprotect, gettid, write, gettimeofday, cacheflush, 
sigprocmask, mmap2, and munmap. While munmap never made the top 10 most frequent system calls for the above applications,
it often fell just outside the top 10, so we decided to include it. With this list, we knew which system calls to recreate in order 
to gather battery usage data.
\newline
\begin{tabular}{l c}
   System Call & \# Appearances \\
   \hline
   clock\_gettime & 10 \\
   ioctl & 10 \\
   getpid & 10 \\
   epoll\_wait & 10 \\
   getuid32 & 10 \\
   futex & 10 \\
   mprotect & 10 \\
   cacheflush & 9 \\
   read & 7 \\
   write & 6 \\
   sigprocmask & 4 \\
   gettid & 2 \\
   gettimeofday & 1 \\
   mmap2 & 1 \\
   munmap & 0 \\ 
\end{tabular}
\newline
{\fontsize{11}{13}\selectfont Table 4.1.1 Frequent System Calls in Popular Android Applications. Appearances denote how many
times a certain system call was in a top 10 most frequent system call list for each of 10 different applications tested.}
\newline

\subsection{System Call C programs}

In developing averages for battery usage per system call, we created C programs for each of the 14 unique system 
calls.  Once these programs were created, we ran a bash script running directly on the device that took a battery 
reading before and after each program completed.  An example system call C program can be seen below in Figure 4.2.1.  

\begin{lstlisting}
/* getclocktime.c */
#include <sys/syscall.h>
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/time.h>

int main() {
  struct timespec ts;
  unsigned long long i;

  //750,000,000 calls
  for(i=0; i<750000000; i++) {
    syscall(SYS_clock_gettime, CLOCK_REALTIME, &ts);
  }
  return EXIT_SUCCESS;
}
\end{lstlisting}

{\fontsize{11}{13}\selectfont Figure 4.2.1 Example C Program for get\_clocktime system call.}
\newline

While the execution time and number of calls made varied among programs, they all ran for at least ten minutes, giving
us a significant change in battery. After running the script for each program, we recorded an average of battery level 
consumption per system call for each of the 14 unique most frequent.  See results in Table 4.2.1.

\begin{tabular}{l c}
   System Call & \# Battery Consumption \\
   \hline
   clock\_gettime & XX \\
   ioctl & XX \\
   getpid & XX \\
   epoll\_wait & XX \\
   getuid32 & XX \\
   futex & XX \\
   mprotect & XX \\
   cacheflush & XX \\
   read & XX \\
   write & XX \\
   sigprocmask & XX \\
   gettid & XX \\
   gettimeofday & XX \\
   mmap2 & XX \\
   munmap & XX \\ 
\end{tabular}
\newline
{\fontsize{11}{13}\selectfont Table 4.2.1 Battery Consumption of System Calls. For readability consumption is display
per every 1,000,000 calls.}
\newline

These take a really long time to run. Still in process of getting statistics. Will add a bit more here and fill in values once
collected.

\subsection{Prediction Data}

To make our predictions on battery usage of popular Android applications based off of battery consumption per call statistics,
we needed a complete list of system calls made by application including the number of times each system call was made.  Using
\textit{strace}, we attached to application-specific processes and recorded the desired data. In addition, we recorded the battery level 
before and after to enable comparison later between predicted consumption to observed battery consumption.  The Android 
applications we used for predictions included Google Maps, Facebook, Youtube, and Pandora.  Observed consumption 
data can be found in Table 4.4.1.

\subsection{Predictions}

With prediction data (which systems calls are made by a certain application and their frequencies) and average consumption per
system call recorded, predicting battery usage was a matter of summing the estimated consumption of each system call.  With this summation,
we subtracted our power reading for a baseline trace and arrived at a prediction for applications' overall battery usage.

When calculating these predictions, we only had the ability to factor consumption of system calls we had average consumption statistics for.  
While this may seem limiting, our most popular system calls covered the top 14 used system calls for each application tested.  Comparison 
between predicted consumption and observed consumpted can be seen below in Table 4.4.1.

\begin{tabular}{l c r}
   Application & Predicted & Observed \\
   \hline
   Google Maps & XX & 6 \\
   Facebook & XX & 4 \\
   Youtube & XX & 5 \\
   Pandora & XX & 4 \\
\end{tabular}
\newline        
{\fontsize{11}{13}\selectfont Table 4.4.1 Battery Consumption Predictions and Observations.}
\newline

Waiting on completion of Table 4.2.1 to complete this section. 

\subsection{Analysis of Error \& Future Work}
Our project turned out to have had inherent flaws in the experimental design that naturally led to errors--the difference between the predicted 
values and the actual readings, as can be witnessed from the Figure 4.2.1. We have come down to three main issues that we would like to discuss 
in this section:

\begin{itemize}
  \item Lack of system call parameters: Parameters are passed to system calls in the same way that they are passed to other functions. 
  These parameters contain important information that guides a system call’s behavior. Same system calls with different parameters are essentially 
  carrying out different tasks. In the C programs that we wrote, we ran system calls that passed generic parameters that do not necessarily match 
  those that were actually called in the test applications. In other words, it is possible that a system call with a particular set of parameters 
  drain more battery than the same system call with another set of parameters. Thus, it is likely that errors might have occurred from this difference. 
  \item Insufficient data collection: Our predictions are calculations of data from 14 most frequent system calls instead of all the system calls 
  that were called from the applications. This design rules out the possibility of less frequent system calls that are more power hungry. If these 
  system calls were present, the power usage data we managed to collect from the top 14 system calls were not fully indicative of the actual power usage. 
  \item Design of our C programs: We designed our C programs so that each runs a single system call repeatedly in a for loop for a set number of iterations. 
  Though this was a clever manipulation of the knowledge we were given, we concluded that it might not have been the best design. For instance, when `getpid’ 
  is called the first time, the value returned from calling the system call is put into the cache. Thus, for the rest of the iterations, power usage is 
  significantly diminished, and does not accurately represent the actual power usage. 

In the future, we would like to improve upon these errors, making our experimental design more accurate and complete. Furthermore, we hope to expand our project, 
so that it can be used as a useful guide for battery-conscious smartphone users. 
\end{itemize}

\section{Conclusions}

CONCLUSION... Waiting on completion of Table 4.2.1 to complete this section.

\bibliographystyle{cs65f12}
\bibliography{cs65f12}

\end{document}

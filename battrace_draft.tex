\documentclass[11pt]{article}
\usepackage{cs65f12}
\usepackage{times}
\usepackage{latexsym}
\usepackage{ulem}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}
\setlength\titlebox{6.5cm}    % Expanding the titlebox

\title{BatTrace: Android battery performance testing via system call tracing}

\author{Yeayeun Park\\
{\tt ypark2@swarthmore.edu}
\And 
Mark Serrano\\
{\tt mserran2@swarthmore.edu}
\AND
Craig Pentrack\\                 
{\tt cpentra1@swarthmore.edu}}

\date{12/06/13}

\begin{document}
\maketitle
\begin{abstract}
  The increasing number of tasks we can perform on our mobile devices 
  feeds positively into the demand for devices with longer battery power. 
  Since mobile devices have become integral parts of our daily lives with
  the number of tasks we can accomplish far outpacing battery performance 
  improvements, consumers have increasingly encountered the issue of 
  efficient device usage and battery life management. In this paper, we 
  examine Android devices in particular and present BatTrace, an Android 
  analysis tool that evaluates battery performance on the android platform
  by tracing system calls. BatTrace will execute different types of popular system
  calls, and extract the correlation between a particular system call and its 
  influence on the battery. Subsequently, it will trace system calls made by 
  individual Android applications and use system call performance data to profile
  each application. Finally, the analysis on the correlation between system calls and their 
  battery usage, as well as the correlation between each application and system 
  calls they initiate, will be combined to estimate battery usage 
  of individual Android applications.
\end{abstract}

\section{Introduction}
Our project is motivated by an issue that we face daily: limited battery power 
on our mobile devices. The vast power available at our fingertips in mobile
devices is tamed by the amount of battery physically available. Given 
that dynamic analysis executes data in real-time to evaluate and test programs, 
we utilized \textit{strace} in combination with C programs and Android system data to perform 
dynamic analysis on Android devices, uncovering low-level explanations as to what is really 
draining the battery.

Hypothesizing system calls to be the key to understanding battery usage at a low-level, we 
used \textit{strace} to profile applications system call usage.  Such testing gave us aggregate
statistics on which system calls were used and how often.  In the process of tracing popular
3rd party applications (e.g. Facebook, Gmail, etc.), we also recorded battery usage by utilizing
built in Android system data pre and post traces.  

Once aware of the most used system calls, we created C programs to repeatedly run those calls and
collect battery statistics.  These programs gave us a measure of how much battery each system call 
consumes on average.  From the aggregate trace data and average system call consumption data, we were 
able to make predictions on battery usage of 3rd party applications.  In collecting high level 
data on battery consumption, we hope to better inform Android users which applications drain their 
battery level most, providing a good set of guidelines for mobile users to follow when low battery 
crisises hit.  With our fine-grained system call data, we hope to better inform software developers 
and hardware manufacturers which system calls consume the most power.   

\section{Background and related work}

Historically much power consumption research has focused on using utilization-based
methods (on individual components, e.g. CPU).  However, modern smartphones employ complex 
power strategies in device drivers and OS-level power management, sometimes rendering utilization as a poor 
model for representing power states and deducing battery usage ~\cite{pathak-systemcall}.  While 
sometimes strong correlation exists between utilization and power consumption, often 
applications have constant power consumption while in certain states (while 
utilization fluctuates) or have high power consumption while low utilization ~\cite{pathak-systemcall,google-androiddev}.  
Additionally, measuring utilization via performance counters results in accuracy 
loss ~\cite{pathak-systemcall}.  Instead of modeling power with utilization, system calls, the only way of 
interacting with hardware and performing I/O, serve as a much more precise indicator 
of power consumption ~\cite{pathak-systemcall}.  Past work and tools, such as eProf, have shown system 
calls to be an effective way of modeling power ~\cite{pathak-systemcall,yoon-appscope,pathak-eprof,ding-signals}.  Using the findings 
of eProf and other studies as justification, we measured and classified system 
calls on Android smartphones in terms of their effect on battery life.

While eProf foregrounded system calls as an effective indicator of changes in power
state, eProf used system calls as a means toward profiling applications' power 
consumption on a sub-routine level ~\cite{pathak-systemcall,pathak-eprof}.  Developing models based off of system 
calls supplied a powerful tool, however the eProf research did not study battery drain 
as a result of  particular system calls themselves and the frequency with which 
applications rely on certain system calls.  Other work in smartphone battery 
research, including detecting energy-related bugs, correlating wireless signal strength 
with battery consumption, and generating battery usage information on the process or 
application level, has relied on system calls ~\cite{yoon-appscope,pathak-bugs,ding-signals}.  We plan to supplement the 
research area by focusing our study on the system calls themselves, rather than using 
them as a means in tracking changes in power state, detecting bugs, measuring signal 
strength effects, or producing higher-level profilings as explored previously.

\section{Our Idea}

While dynamic analysis on traditional devices involves the most efficient use of finite 
computing resources, mobile devices introduce a new problem; finite power. The issue we 
immediately encounter when trying to analyze mobile software applications is that we 
\sout{almost} never have access to the source code of the applications. This is 
especially true given the fact that most mobile software is proprietary in nature, 
leaving open source software to the relics that are desktop computers.

\begin{figure}[h]
  \centerline{
        \includegraphics[width=90mm]{images/environment_graphic.png}
  }
  \caption{The Android environment stack. Trace location marks where we will be intercepting system calls}
  
 \end{figure}

With this in mind we set out find a way of measuring mobile battery usage at very low level
(software wise). We decided a good approach would involve monitoring activity at the system 
call level using a tool like \textit{strace}. Ideally, we want to profile a variety of system calls 
based on how much battery is used while they are running. We intend to establish a baseline 
battery consumption level so we know how much battery is used by just the OS. Then, using 
simple programs that repeatedly make the same system call X times, we can determine how much 
battery was used as a result of initiating a particular system call X times.

Once system calls were profiled, we proceeded to the last phase of the analysis. Our 
goal was to identify the system calls initiated by the Dalvik VM as a result of running an 
individual app. By identifying the types of system calls, as well as the number of calls made 
to an individual system call, we were able to predict the app's impact on the battery based 
on what we learned about battery usage for individual system calls. While this approach may not 
be the most accurate, we believe it is the broadest approach that will allow us to profile any 
application regardless of the author or the nature of the software's license.

\section{Evaluation}

In the process of analyzing battery usage through system call tracing we successfully
found most used system calls by popular Android applications, wrote C programs to 
repeatedly execute those system calls, recorded battery usage as a result of particular 
system calls, gathered system call data of popular apps dynamically, and made predictions 
based on the aforementioned data.  This section is split into subsections based on the above
categories.

\subsection{Popular System Calls}

In order calculate accurate estimates of battery usage, we first traced 10 popular Android
applications to acquire a list of the most significant system calls (i.e. ones that were
called with the highest frequency).  We traced Google Maps, Facebook, Angry Birds, Youtube, Google Play,
Gmail, Twitter, Skype, Pandora, and Instagram using \textit{strace}, collecting the ten most 
used system calls by each.  Applications were run for at least 2 minutes simulating normal 
usage patters. The results appear in the Table 4.1.1.

Distilling the results, we found that there were 14 most frequent and unique system calls. They included:
clock\_gettime, ioctl, getpid, epoll\_wait, getuid32, futex, read, mprotect, gettid, write, gettimeofday, cacheflush, 
sigprocmask, mmap2, and munmap. While munmap never made the top 10 most frequent system calls for the above applications,
it often fell just outside the top 10, so we decided to include it. With this list, we knew which system calls to recreate in order 
to gather battery usage data.
\newline
\begin{tabular}{l c}
   System Call & \# Appearances \\
   \hline
   clock\_gettime & 10 \\
   ioctl & 10 \\
   getpid & 10 \\
   epoll\_wait & 10 \\
   getuid32 & 10 \\
   futex & 10 \\
   mprotect & 10 \\
   cacheflush & 9 \\
   read & 7 \\
   write & 6 \\
   sigprocmask & 4 \\
   gettid & 2 \\
   gettimeofday & 1 \\
   mmap2 & 1 \\
   munmap & 0 \\ 
\end{tabular}
\newline
{\fontsize{11}{13}\selectfont Table 4.1.1 Frequent System Calls in Popular Android Applications. Appearances denote how many
times a certain system call was in a top 10 most frequent system call list for each of 10 different applications tested.}
\newline

\subsection{System Call C programs}

In developing averages for battery usage per system call, we created C programs for each of the 14 unique system 
calls.  Once these programs were created, we ran a bash script running directly on the device that took a battery 
reading before and after each program completed.  An example system call C program can be seen below in Figure 4.2.1.  

\begin{lstlisting}
/* getclocktime.c */
#include <sys/syscall.h>
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/time.h>

int main() {
  struct timespec ts;
  unsigned long long i;

  //750,000,000 calls
  for(i=0; i<750000000; i++) {
    syscall(SYS_clock_gettime, CLOCK_REALTIME, &ts);
  }
  return EXIT_SUCCESS;
}
\end{lstlisting}

{\fontsize{11}{13}\selectfont Figure 4.2.1 Example C Program for get\_clocktime system call.}
\newline

While the execution time and number of calls made varied among programs, they all ran for at least ten minutes, giving
us a significant change in battery. After running the script for each program, we recorded an average of battery level 
consumption per system call for each of the 14 unique most frequent.  See results in Table 4.2.1.

\begin{tabular}{l c}
   System Call & \# Battery Consumption \\
   \hline
   clock\_gettime & XX \\
   ioctl & XX \\
   getpid & XX \\
   epoll\_wait & XX \\
   getuid32 & XX \\
   futex & XX \\
   mprotect & XX \\
   cacheflush & XX \\
   read & XX \\
   write & XX \\
   sigprocmask & XX \\
   gettid & XX \\
   gettimeofday & XX \\
   mmap2 & XX \\
   munmap & XX \\ 
\end{tabular}
\newline
{\fontsize{11}{13}\selectfont Table 4.2.1 Battery Consumption of System Calls. For readability consumption is display
per every 1,000,000 calls.}
\newline

These take a really long time to run. Still in process of getting statistics. Will add a bit more here and fill in values once
collected.

\subsection{Prediction Data}

To make our predictions on battery usage of popular Android applications based off of battery consumption per call statistics,
we needed a complete list of system calls made by application including the number of times each system call was made.  Using
\textit{strace}, we attached to application-specific processes and recorded the desired data. In addition, we recorded the battery level 
before and after to enable comparison later between predicted consumption to observed battery consumption.  The Android 
applications we used for predictions included Google Maps, Facebook, Youtube, and Pandora.  Observed consumption 
data can be found in Table 4.4.1.

\subsection{Predictions}

With prediction data (which systems calls are made by a certain application and their frequencies) and average consumption per
system call recorded, predicting battery usage was a matter of summing the estimated consumption of each system call.  With this summation,
we subtracted our power reading for a baseline trace and arrived at a prediction for applications' overall battery usage.

When calculating these predictions, we only had the ability to factor consumption of system calls we had average consumption statistics for.  
While this may seem limiting, our most popular system calls covered the top 14 used system calls for each application tested.  Comparison 
between predicted consumption and observed consumpted can be seen below in Table 4.4.1.

\begin{tabular}{l c r}
   Application & Predicted & Observed \\
   \hline
   Google Maps & XX & 6 \\
   Facebook & XX & 4 \\
   Youtube & XX & 5 \\
   Pandora & XX & 4 \\
\end{tabular}
\newline        
{\fontsize{11}{13}\selectfont Table 4.4.1 Battery Consumption Predictions and Observations.}
\newline

Waiting on completion of Table 4.2.1 to complete this section. 

\subsection{Analysis of Error \& Future Work}
Once we have Table 4.2.1 we can perform analysis of our error and outline future work.  Anticipating that the discussion will
include:
\begin{itemize}
  \item didn't factor in varying system call parameters
  \item only captured 14 most used system calls for each application
  \item only tested on one device
  \item battery levels were imprecise (x/100)
\end{itemize}

\section{Conclusions}

CONCLUSION... Waiting on completion of Table 4.2.1 to complete this section.

\bibliographystyle{cs65f12}
\bibliography{cs65f12}

\end{document}
